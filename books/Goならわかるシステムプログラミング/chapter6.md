# TCPソケットとHTTPの実装
## プロトコルとレイヤー
- 通信を行うためのルールをプロトコルという

## HTTPとその上のプロトコルたち
### HTTPの基本
- HTTPには、HTTP/1.0, HTTP/1.1, HTTP/2というバージョンがある
- リクエストの形式
```
メソッド パス HTTP/1.0
ヘッダー1: ヘッダーの値
ヘッダー2: ヘッダーの値
(空行)
リクエストボディー(あれば)
```
- レスポンスの形式
```
HTTP/1.0 200 OK
ヘッダー1: ヘッダーの値
ヘッダー2: ヘッダーの値
(空行)
サーバーレスポンス
```
### RPC
- RPC(Remote Procedure Call)は、サーバーが用意している様々な機能をローカルコンピュータ上にある関数のように簡単に呼び出そう、という仕組みのこと
  - XML-RPC, JSON-RPCといった形でHTTP上プロトコルとして利用されてきた

### REST
- 全てを階層化されたリソースとみなして、URLを使ってそれらのリソースを取得したり投稿したりするような考え方のスタイルをRESTと呼ぶ

### GraphQL
- RPCベースでアプリケーション層のプロトコル
- Facebook社が提唱している
- 複数の属性から構成されている要素をピンポイントで取得するためのクエリー言語として機能する

## ソケットとは
- ほとんどのOSではアプリケーション層からトランスポート層のプロトコルを利用するときのAPIとしてソケットという仕組みを利用する
- ソケットが他のプロセス間通信と違うのは、アドレスとポート番号がわかればローカルコンピューター内だけではなく、外部のコンピューターとも通信が行えること
- ソケットにはいくつか種類がある
  - TCP
    - 一番使われている。安定性が高い。
  - UDP
    - 通信開始が早い。相手に一方的に送りつける
  - Unixドメインソケット
    - ローカル通信でしか使えないが、最速。

## ソケット通信の基本構造
- 基本となる構成
  - サーバー: ソケットを開いて待ち受ける
  - クライアント: 開いているソケットに接続し、通信を行う
- TCPサーバーの例
```go
ln, err := net.Listen("tcp", "localhost:8080")
if err != nil {
  panic(err)
}

// 一度で終了しないようにAccept()を繰り返し呼ぶ
for {
  conn, err := ln.Accept()
  if err != nil {
    // handle error
  }
  
  // リクエスト処理中に他のリクエストのAccept()が行えるように
  // Goroutineで非同期にレスポンスを処理する
  go func() {
  
  }()
}
```

## 速度改善(1): HTTP/1.1のKeep-Aliveに対応させる
- HTTP/1.1から入ったKeep-Aliveを使うことで1メッセージごとにCloseするのではなく、しばらくの間TCP接続のコネクションを維持して使いまわすことができる


