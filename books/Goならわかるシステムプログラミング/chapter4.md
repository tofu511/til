# 低レベルアクセスへの入口3: チャネル
## goroutine
- Go言語はgoroutineという並列処理機構を備えている

## チャネル
- Goのチャネルはキューに「並列でアクセスされても正しく処理される」ことを保証する機能を組み合わせたもの
- チャネルの機能は分解すると3つの性質がある
  - チャネルはデータを順序よく受け渡すためのデータ構造である
    - キューとしてのチャネルはデータを貯める配列である
    - 普通の配列とは異なりランダムアクセスはできない
  - チャネルは並列処理されても正しくデータを受け渡す同期機構である
    - チャネルは整合性が壊れることのない安全なデータ構造になっている
    - データ投入とデータ取り出しが同時に1つのgoroutineしかできないようになっている
  - チャネルは読み込み・書き込みで準備ができるまでブロックする機能である
    - データがない状態で読み込みをしようとすると、他のgoroutineがそのチャネルにデータを投入して読み込みの準備ができるまでブロックして待つ
    - バッファに空きがない状態で書き込みをしようとすると、他のgoroutineがデータを取り出して空きができるまでブロックする
 
### チャネルの使用方法
- チャネルを作るにはmake()を使う
```go
tasks := make(chan string) // バッファなし
tasks := make(chan string, 10) // バッファ付き
```

- チャネルへデータを送信したり、チャネルからデータを受け取りには<-演算子を使う
```go
// データを送信
tasks <- "cmake.."
tasks <- "cmake. --build Debug"

// データを受け取り
task := <- tasks
// データ受け取り&クローズ判定
task, ok := <- tasks
// データを読み捨てる場合は代入文も不要
<- wait
```

- バッファなしのチャネルでは受け取り側が受信しないと送信側もブロックされる
- 読み込みは基本的に送信側が送信するまでブロックする
  - ブロックを避けるにはselectを使う
- チャネルを閉じるにはclose(chan)を呼ぶ
- チャネルは何かしらのイベントの通知で使われることがよくある
