# 第3章 依存関係を管理する
- 適切に設計されたオブジェクトは単一の責任をもつが、複雑な問題を解決するには共同作業をする必要がある
- 共同作業をするには他のオブジェクトを知っていないといけないが、知っているというのは同時に依存を作り出してしまう

## 依存関係を理解する
- 一方のオブジェクトに変更を加えた時に他方のオブジェクトも変更せざるおえない場合、片方のオブジェクトに依存している

### オブジェクト間の結合(CBO: Coupling Between Objects)
- 2つのオブジェクトの結合が強固な時、それらはあたかも1つのユニットであるかのように振る舞う
  - 1つだけ再利用するということはできない
  - 1つに変更を加えると全てのオブジェクトに変更を加えないといけない

### 他の依存関係
- いくつものメッセージをチェーンのように繋いで、遠くのオブジェクトに存在する振る舞いを実行しようとする場合、破壊的なたぐいの依存が生じる
  - 元のオブジェクトから最終的な目的地の間に依存関係を作り出す
  
## 疎結合なコードを書く
  
### 依存オブジェクトの注入
- 例えば、インスタンス作成をハードコーディングしてしまうのではなく、引数として渡し、クラス外に移動することで、2つのクラス間の結合を切り離すことができる
  - サンプルコードの例だと、Gearクラスの中でWheelをnewするのではなく、引数としてWheelを渡してあげる
  - このテクニックを**依存オブジェクトの注入(dependency injection)**という
- クラス名を知っておく責任やクラスに送るメソッド名を知っておく責任がどこか他にないかと疑うことが重要

## 依存方向の管理

### 依存関係の逆転
- 2章の例ではGearがWheelまたはdiameterに依存していたが、依存関係を逆転させたコードも書くことができる
  - [Gear.scala](https://github.com/tofu511/til/blob/master/books/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E8%A8%AD%E8%A8%88%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/chapter3/Gear.scala)
  - [Wheel.scala](https://github.com/tofu511/til/blob/master/books/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E8%A8%AD%E8%A8%88%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89/chapter3/Wheel.scala)

### 依存方向の選択
- 依存方向を選択するときは**自身より変更されないものに依存する**
  - あるクラスは他のクラスよりも要件が変わりやすい
  - 具象クラスは抽象クラスよりも変わる可能性が高い
  - 多くのところから依存されたクラスを変更すると、広範囲に影響が及ぶ

### 変更のおきやすさを理解する
- 言語の基本的なクラスが大きく変わることは自身のコードが変わるよりは少ない
  - String, Arrayなど
- フレームワークのコードは基本的には自身の書くコードよりは安定的
- フレームワークが発展途上で開発が活発だと自身のコードよりもフレームワークのコードの方が頻繁に変わるということもありえる

### 具象と抽象を認識する
- 抽象とは「いかなる特定の実例(インスタンス)からも離れている」こと
- GearやWheelをクラス内部でnewしている場合、具象的なコードに依存している(GearもしくはWheelに依存している)
- GearオブジェクトやWheelオブジェクトを外部から注入することで具象よりは抽象的なものになった(Rubyの場合)
  - 静的な言語ではInterfaceを使う必要がある


