# 単一責任のクラスを設計する
- クラスを使い、今すぐに求められる動作を行い、かつ後にも簡単に変更できるようにモデル化する

## クラスに属するものを決める

### 変更がかんたんなようにコードを組成する
- コードは次のようにあるべき

##### 見通しが良い(Transparent)
- 変更するコードにおいても、そのコードに依存する別の場所のコードにおいても、変更がもたらす影響が明白である

##### 合理的(Reasonable)
- どんな変更であっても、かかるコストは変更がもたらす利益にふさわしい

##### 利用性が高い(Usable)
- 新しい環境、予期していなかった環境でも再利用できる

##### 模範的(Exemplary)
- コードに変更を加える人が、上記の品質を自然と保つようなコードになっている

## 単一の責任を持つクラスを作る

### アプリケーション例: 自転車とギア
- Scalaでかくとこんな感じ
```scala
case class Gear(chainring: Int, cog: Int, rim: Int, tire: Int) {
  def ratio = chainring / cog.toFloat
  def gearInches = ratio * (rim + (tire * 2))
}
```

```scala
class Gear(val chainring: Int, val cog: Int, rim: Int, tire: Int) {
  def ratio = chainring / cog.toFloat
  def gearInches = ratio * (rim + (tire * 2))
}
```
- 上記の例はギアクラスがタイヤを保持しているので単一責任にはなっていない
  - ギアの役割を超えている
  - とはいえこれは自転車という最終完成形を知っているからという側面もある

### なぜ単一責任が重要なのか
- 2つ以上の責任を持つクラスはかんたんには再利用できない
- 多岐にわたる責任はクラス内部に完全に絡みついてしまいがち
- 振る舞いを再利用したくても、必要な部分だけを手に入れることは到底できない

### クラスが単一責任がどうかを見極める
- クラスが実際に何をしているかを定めるには1文でクラスが説明できるかやってみると良い
  - 「それと」とか「または」とかがあると責任が複数ある
- 凝集度とも言う
- クラス内の全てがそのクラスの中心的な目的に関連していればそのクラスは凝集度が高いと言う

### 設計する時を見極める
- 何もしないことによる将来的なコストが今と変わらない時は決定を延期する
- 現時点での要件と未来の可能性の相互間のトレードオフをよく理解して、コストが最小になるように決断をする(<-これがむずい)

### 変更を歓迎するコードを書く
- 単一責任のクラスを作れば、どんな些細な振る舞いもそれぞれがただ１箇所のみに存在するようになる(DRY)
- 複雑な構造への直接の参照は混乱を招く
- `class RevealingReferences`のScala実装例










